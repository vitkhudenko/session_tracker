<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SessionTracker.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">session_tracker_lib</a> &gt; <a href="index.source.html" class="el_package">vit.khudenko.android.sessiontracker</a> &gt; <span class="el_source">SessionTracker.kt</span></div><h1>SessionTracker.kt</h1><pre class="source lang-java linenums">package vit.khudenko.android.sessiontracker

import android.util.Log
import vit.khudenko.android.fsm.StateMachine

/**
 * ## TL;DR
 *
 * SessionTracker is a general purpose framework to provide a foundation for session management in your app.
 *
 * Your app provides (a) session tracking storage implementation and (b) session tracking state machine configuration,
 * while SessionTracker provides callbacks to create/update/release session resources.
 *
 * ## Contract description
 *
 * ### What is session?
 *
 * Session is a flexible entity - it could be a user session with user signing in/out or a bluetooth device session
 * with all its possible states.
 *
 * ### Session tracking state VS. session state
 *
 * In SessionTracker framework, sessions are represented by session tracking records - instances of
 * [`SessionRecord`][SessionRecord]. It is an immutable data structure, that has just 2 fields - session ID and
 * session tracking state.
 *
 * Note, there are two (partially intersecting) types of session state:
 * 1. The session state that is tracked by SessionTracker, which is always an instance of enum by the contract.
 * 2. The session state that is specific to your app, which can be as diverse as your app's business logic requires
 * and which can not be represented by the [`SessionRecord`][SessionRecord].
 *
 * Please don't mess one with another. Actual implementation of session, including its persistence, is up to your app
 * and is out of SessionTracker framework responsibility. It is correct to say that session tracking state (the one
 * tracked by SessionTracker) is a subset of a full session state in your app.
 *
 * ### Persistence
 *
 * SessionTracker framework supports session tracking auto-restoration on application process restarts. Your
 * app must provide an implementation of [`ISessionTrackerStorage`][ISessionTrackerStorage], which is used by
 * SessionTracker to make CRUD operations on session tracking records.
 *
 * ### Session tracking state machine
 *
 * SessionTracker maintains a state machine per session. Your app must define a set of possible events and
 * states per session. Using events and states, your app should provide state machine transitions, which are
 * used to configure session state machine. For example, your app may define the following session tracking events
 * and states:
 *
 * ```kotlin
 *     enum class State {
 *         INACTIVE, ACTIVE
 *     }
 *     enum class Event {
 *         LOGIN, LOGOUT
 *     }
 * ```
 *
 * then a sample transitions config (an implementation of
 * [`ISessionStateTransitionsSupplier`][ISessionStateTransitionsSupplier]) could be as following:
 *
 * ```kotlin
 *     val sessionStateTransitionsSupplier = object : ISessionStateTransitionsSupplier&lt;Event, State&gt; {
 *         override fun getStateTransitions(sessionId: SessionId) = listOf(
 *             Transition(
 *                 event = Event.LOGIN,
 *                 statePath = listOf(State.INACTIVE, State.ACTIVE)
 *             ),
 *             Transition(
 *                 event = Event.LOGOUT,
 *                 statePath = listOf(State.ACTIVE, State.INACTIVE)
 *             )
 *         )
 *     }
 * ```
 *
 * Such config would mean there are two possible session tracking states (`ACTIVE`/`INACTIVE`) and two possible session
 * tracking events: `LOGIN` (to move session from `INACTIVE` to `ACTIVE` state) and `LOGOUT` (to move session from
 * `ACTIVE` to `INACTIVE` state).
 *
 * ### Session tracking
 *
 * In order to make SessionTracker ready to function it should be initialized first. The most appropriate place for
 * [`initialize()`][initialize] call is
 * [`Application.onCreate()`][android.app.Application.onCreate].
 *
 * Suppose your user hits &quot;Login&quot; button, your app authenticates user and creates a session. In order to make
 * use of SessionTracker the session should be &quot;attached&quot; to SessionTracker:
 *
 * ```kotlin
 *     sessionTracker.trackSession(sessionId, State.ACTIVE)
 * ```
 *
 * Now SessionTracker is tracking the session until your app calls [`untrackSession(sessionId)`][untrackSession].
 * Next time your app starts (and SessionTracker is initialized), the session tracking will be automatically restored
 * by SessionTracker with the same `ACTIVE` state.
 *
 * As long as session is tracked, its session tracking state changes are propagated to your app via
 * [`SessionTracker.Listener`][SessionTracker.Listener].
 *
 * Suppose eventually your user hits &quot;Log Out&quot; button, then your app is responsible to communicate this event
 * to SessionTracker by asking to consume `LOGOUT` event for the session:
 *
 * ```kotlin
 *     sessionTracker.consumeEvent(sessionId, Event.LOGOUT)
 * ```
 *
 * Now SessionTracker updates session tracking state to `INACTIVE`, persists session record with the new state and
 * propagates this state change via [`SessionTracker.Listener`][SessionTracker.Listener]. Note, the session
 * is still tracked by SessionTracker, so next time your app starts, the session tracking will be automatically restored
 * by SessionTracker with the same `INACTIVE` state.
 *
 * ### Management of session resources
 *
 * [`SessionTracker.Listener`][SessionTracker.Listener] has useful for your app callbacks that allow to manage session
 * resources appropriately:
 *
 * - `onSessionTrackerInitialized(sessionTracker: SessionTracker&lt;Event, State&gt;, sessionRecords: List&lt;SessionRecord&lt;State&gt;&gt;)` -
 *     SessionTracker has added sessions to the list of tracked sessions.
 *     This happens as a result of calling [`SessionTracker.initialize()`][initialize].
 *     This callback is the right place to create any resources for the sessions (a DB connection, a DI scope, etc.).
 *
 * - `onSessionTrackingStarted(sessionTracker: SessionTracker&lt;Event, State&gt;, sessionRecord: SessionRecord&lt;State&gt;)` -
 *     SessionTracker has added session to the list of tracked sessions.
 *     This happens as a result of calling [`SessionTracker.trackSession(sessionId, state)`][trackSession].
 *     This callback is the right place to create any resources for the session (a DB connection, a DI scope, etc.)
 *     depending on the session state (`sessionRecord.state`).
 *
 * - `onSessionStateChanged(sessionTracker: SessionTracker&lt;Event, State&gt;, sessionRecord: SessionRecord&lt;State&gt;, oldState: State)` -
 *     session tracking state has changed.
 *     This happens as a result of calling [`SessionTracker.consumeEvent(sessionId, event)`][consumeEvent].
 *     This callback is the right place to create or release any resources for the session (a DB connection,
 *     a DI scope, etc.).
 *
 * - `onSessionTrackingStopped(sessionTracker: SessionTracker&lt;Event, State&gt;, sessionRecord: SessionRecord&lt;State&gt;)` -
 *     SessionTracker has removed session from the list of tracked sessions. This happens as a result
 *     of calling [`SessionTracker.untrackSession(sessionId)`][untrackSession].
 *     This may also happen as a result of calling [`SessionTracker.consumeEvent`][consumeEvent] if session
 *     appears in one of the [`autoUntrackStates`][autoUntrackStates].
 *     This callback is the right place to release any resources for the session (a DB connection, a DI scope, etc.).
 *
 * - `onAllSessionsTrackingStopped(sessionTracker: SessionTracker&lt;Event, State&gt;, sessionRecords: List&lt;SessionRecord&lt;State&gt;&gt;)` -
 *     SessionTracker has removed session from the list of tracked sessions. This happens as a result
 *     of calling [`SessionTracker.untrackAllSessions()`][untrackAllSessions].
 *     This callback is the right place to release any resources for the sessions (a DB connection, a DI scope, etc.).
 *
 * ## Threading
 *
 * SessionTracker is thread-safe. Public methods are declared as `synchronized`. Thread-safe compound actions are
 * possible by using synchronized statement on `SessionTracker` instance:
 *
 * ```kotlin
 *     synchronized(sessionTracker) {
 *         sessionTracker.consumeEvent(..) // step 1 of the compound action
 *         sessionTracker.consumeEvent(..) // step 2 of the compound action
 *     }
 * ```
 *
 * SessionTracker is a synchronous tool, meaning it neither creates threads nor uses thread-pools.
 *
 * ## Miscellaneous
 *
 * Typical SessionTracker usage implies being a singleton in your app.
 */
<span class="fc" id="L164">class SessionTracker&lt;Event : Enum&lt;Event&gt;, State : Enum&lt;State&gt;&gt;(</span>
    private val sessionTrackerStorage: ISessionTrackerStorage&lt;State&gt;,
    private val sessionStateTransitionsSupplier: ISessionStateTransitionsSupplier&lt;Event, State&gt;,
    private val listener: Listener&lt;Event, State&gt;,
    /**
     * If a session appears in one of these states, then `SessionTracker` automatically untracks such session.
     * The effect of automatic untracking is similar to making an explicit [`untrackSession()`][untrackSession] call.
     *
     * @see [consumeEvent]
     * @see [untrackSession]
     * @see [untrackAllSessions]
     */
    private val autoUntrackStates: Set&lt;State&gt;,
    private val mode: Mode,
<span class="pc" id="L178">    private val logger: Logger = Logger.DefaultImpl(),</span>
<span class="fc" id="L179">    private val logTag: String = TAG</span>
) {

    companion object {
<span class="fc" id="L183">        internal val TAG = SessionTracker::class.java.simpleName</span>
    }

    /**
     * Defines misuse/misconfiguration tolerance and amount of logging.
     *
     * @see [Mode.STRICT]
     * @see [Mode.STRICT_VERBOSE]
     * @see [Mode.RELAXED]
     * @see [Mode.RELAXED_VERBOSE]
     */
<span class="fc" id="L194">    enum class Mode(val strict: Boolean, val verbose: Boolean) {</span>

        /**
         * In this mode SessionTracker does not tolerate most of the misuse/misconfiguration issues by crashing the app.
         *
         * @see [initialize]
         * @see [trackSession]
         * @see [untrackSession]
         * @see [consumeEvent]
         */
<span class="fc" id="L204">        STRICT(strict = true, verbose = false),</span>

        /**
         * Same as [`STRICT`][STRICT], but with more logging.
         */
<span class="fc" id="L209">        STRICT_VERBOSE(strict = true, verbose = true),</span>

        /**
         * In this mode SessionTracker tries to overstep misuse/misconfiguration issues (if possible) by just logging
         * the issue and turning an operation to 'no op'.
         *
         * @see [initialize]
         * @see [trackSession]
         * @see [untrackSession]
         * @see [consumeEvent]
         */
<span class="fc" id="L220">        RELAXED(strict = false, verbose = false),</span>

        /**
         * Same as [`RELAXED`][RELAXED], but with more logging.
         */
<span class="fc" id="L225">        RELAXED_VERBOSE(strict = false, verbose = true)</span>
    }

    /**
     * A listener, through which the session tracking lifecycle and state changes are communicated.
     *
     * @see [onSessionTrackerInitialized]
     * @see [onSessionTrackingStarted]
     * @see [onSessionTrackingStopped]
     * @see [onSessionStateChanged]
     * @see [onAllSessionsTrackingStopped]
     */
    interface Listener&lt;Event : Enum&lt;Event&gt;, State : Enum&lt;State&gt;&gt; {

        /**
         * The `SessionTracker` has added session(s) to the list of tracked sessions. This happens as a result
         * of calling [`SessionTracker.initialize()`][initialize].
         *
         * This callback is the right place to create any resources for the session
         * (a DB connection, a DI scope, etc.).
         */
        fun onSessionTrackerInitialized(
            sessionTracker: SessionTracker&lt;Event, State&gt;,
            sessionRecords: List&lt;SessionRecord&lt;State&gt;&gt;
        )

        /**
         * The `SessionTracker` has added session to the list of tracked sessions. This happens as a result
         * of calling [`SessionTracker.trackSession()`][trackSession].
         *
         * This callback is the right place to create any resources for the session
         * (a DB connection, a DI scope, etc.).
         */
        fun onSessionTrackingStarted(
            sessionTracker: SessionTracker&lt;Event, State&gt;,
            sessionRecord: SessionRecord&lt;State&gt;
        )

        /**
         * The session tracking state has changed from `oldState` to `newState`.
         * This happens as a result of calling [`SessionTracker.consumeEvent()`][consumeEvent].
         *
         * This callback is the right place to create or release any resources
         * for the session (a DB connection, a DI scope, etc.).
         */
        fun onSessionStateChanged(
            sessionTracker: SessionTracker&lt;Event, State&gt;,
            sessionRecord: SessionRecord&lt;State&gt;,
            oldState: State
        )

        /**
         * The `SessionTracker` has removed session from the list of tracked sessions. This happens as a result
         * of calling [`SessionTracker.untrackSession()`][untrackSession].
         *
         * This may also happen as a result of calling [`SessionTracker.consumeEvent()`][SessionTracker.consumeEvent]
         * if session appears in one of the [`autoUntrackStates`][autoUntrackStates].
         *
         * This callback is the right place to release any resources for
         * the session (a DB connection, a DI scope, etc.).
         */
        fun onSessionTrackingStopped(
            sessionTracker: SessionTracker&lt;Event, State&gt;,
            sessionRecord: SessionRecord&lt;State&gt;
        )

        /**
         * The `SessionTracker` has removed all sessions from the list of tracked sessions. This happens as a result
         * of calling [`SessionTracker.untrackAllSessions()`][untrackAllSessions].
         *
         * This callback is the right place to release any resources for
         * the sessions (a DB connection, a DI scope, etc.).
         */
        fun onAllSessionsTrackingStopped(
            sessionTracker: SessionTracker&lt;Event, State&gt;,
            sessionRecords: List&lt;SessionRecord&lt;State&gt;&gt;
        )
    }

    interface Logger {
        fun d(tag: String, message: String)
        fun w(tag: String, message: String)
        fun e(tag: String, message: String)

        /**
         * Default implementation of [`Logger`][Logger] that uses [`android.util.Log`][android.util.Log].
         */
<span class="fc" id="L312">        class DefaultImpl : Logger {</span>
            override fun d(tag: String, message: String) {
<span class="fc" id="L314">                Log.d(tag, message)</span>
<span class="fc" id="L315">            }</span>

            override fun w(tag: String, message: String) {
<span class="fc" id="L318">                Log.w(tag, message)</span>
<span class="fc" id="L319">            }</span>

            override fun e(tag: String, message: String) {
<span class="fc" id="L322">                Log.e(tag, message)</span>
<span class="fc" id="L323">            }</span>
        }
    }

    private var initialized: Boolean = false
<span class="fc" id="L328">    private val sessionsMap = LinkedHashMap&lt;SessionId, SessionInfo&lt;Event, State&gt;&gt;()</span>
    private var persisting = false

    /**
     * Must be called before calling any other methods.
     *
     * Subsequent calls are ignored.
     *
     * This method calls [`ISessionTrackerStorage.readAllSessionRecords()`][ISessionTrackerStorage.readAllSessionRecords],
     * starts tracking the obtained session records and notifies session tracker listener (see
     * [`Listener.onSessionTrackingStarted()`][Listener.onSessionTrackingStarted]).
     *
     * @throws [RuntimeException] for a strict [`mode`][mode], if [`autoUntrackStates`][autoUntrackStates] are defined
     * AND session is in one of such states. For a relaxed [`mode`][mode] it just logs an error message and skips such
     * session from tracking.
     * @throws [RuntimeException] for a strict [`mode`][mode], if
     * [`sessionStateTransitionsSupplier`][sessionStateTransitionsSupplier] returns transitions that cause validation
     * errors while creating session tracking state machine. For a relaxed [`mode`][mode] it just logs an error
     * message and skips such session from tracking.
     */
    @Synchronized
    fun initialize() {
<span class="fc" id="L350">        val startedAt = System.currentTimeMillis()</span>

<span class="fc bfc" id="L352" title="All 2 branches covered.">        if (initialized) {</span>
<span class="fc" id="L353">            logger.w(logTag, &quot;initialize: already initialized, skipping..&quot;)</span>
<span class="fc" id="L354">            return</span>
        }

<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (mode.verbose) {</span>
<span class="fc" id="L358">            logger.d(logTag, &quot;initialize: starting..&quot;)</span>
        }

<span class="fc" id="L361">        val loadedSessionRecords = sessionTrackerStorage.readAllSessionRecords()</span>

<span class="fc" id="L363">        loadedSessionRecords</span>
<span class="fc" id="L364">            .filter { sessionRecord -&gt;</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">                sessionRecord.state in autoUntrackStates</span>
<span class="fc" id="L366">            }.forEach { (sessionId, state) -&gt;</span>
<span class="fc" id="L367">                val explanation = &quot;session with ID '${sessionId}' is in auto-untrack state (${state})&quot;</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">                if (mode.strict) {</span>
<span class="fc" id="L369">                    throw RuntimeException(&quot;Unable to initialize $logTag: $explanation&quot;)</span>
                } else {
<span class="fc" id="L371">                    logger.e(logTag, &quot;initialize: $explanation, rejecting this session&quot;)</span>
                }
<span class="fc" id="L373">            }</span>

<span class="fc" id="L375">        val initializedSessionRecords = mutableMapOf&lt;SessionId, SessionRecord&lt;State&gt;&gt;()</span>

<span class="fc" id="L377">        loadedSessionRecords</span>
<span class="fc" id="L378">            .filterNot { sessionRecord -&gt;</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">                sessionRecord.state in autoUntrackStates</span>
            }
<span class="fc" id="L381">            .map { sessionRecord -&gt;</span>
<span class="fc" id="L382">                val stateMachine = try {</span>
<span class="fc" id="L383">                    setupSessionStateMachine(sessionRecord)</span>
<span class="fc" id="L384">                } catch (e: Exception) {</span>
<span class="fc" id="L385">                    throw RuntimeException(</span>
<span class="fc" id="L386">                        &quot;Unable to initialize $logTag: error creating ${StateMachine::class.java.simpleName}&quot;, e</span>
                    )
                }
<span class="fc" id="L389">                sessionRecord to stateMachine</span>
            }
<span class="fc" id="L391">            .forEach { (sessionRecord, stateMachine) -&gt;</span>
<span class="fc" id="L392">                sessionsMap[sessionRecord.sessionId] = SessionInfo(stateMachine)</span>
<span class="fc" id="L393">                initializedSessionRecords[sessionRecord.sessionId] = sessionRecord</span>
<span class="fc" id="L394">            }</span>

<span class="fc" id="L396">        listener.onSessionTrackerInitialized(this, initializedSessionRecords.values.toList())</span>

<span class="fc" id="L398">        initialized = true</span>

<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (mode.verbose) {</span>
<span class="fc" id="L401">            logger.d(logTag, &quot;initialize: done, took ${System.currentTimeMillis() - startedAt} ms&quot;)</span>
        }
<span class="fc" id="L403">    }</span>

    /**
     * @return a list of the currently tracked session records.
     *
     * @throws [RuntimeException] for a strict [`mode`][mode], if `SessionTracker` has not been initialized.
     * For a relaxed [`mode`][mode] it just logs an error message and returns an empty list.
     */
    @Synchronized
    fun getSessionRecords(): List&lt;SessionRecord&lt;State&gt;&gt; {
<span class="fc bfc" id="L413" title="All 2 branches covered.">        return if (ensureInitialized(&quot;getSessionRecords&quot;)) {</span>
<span class="fc" id="L414">            val sessionRecords = sessionsMap.entries.map {</span>
<span class="fc" id="L415">                SessionRecord(sessionId = it.key, state = it.value.stateMachine.getCurrentState())</span>
<span class="fc" id="L416">            }.toMutableList()</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">            if (mode.verbose) {</span>
<span class="fc" id="L418">                val dump = sessionRecords.joinToString(</span>
<span class="fc" id="L419">                    prefix = &quot;[&quot;, postfix = &quot;]&quot;</span>
<span class="fc" id="L420">                ) { (sessionId, state) -&gt; &quot;{ '${sessionId}': $state }&quot; }</span>
<span class="fc" id="L421">                logger.d(logTag, &quot;getSessionRecords: $dump&quot;)</span>
            }
<span class="fc" id="L423">            sessionRecords</span>
        } else {
<span class="fc" id="L425">            emptyList()</span>
        }
    }

    /**
     * Starts tracking a session for the sessionId, persists a new session record via
     * [`ISessionTrackerStorage`][ISessionTrackerStorage] and notifies session tracker listener
     * (see [`SessionTracker.Listener.onSessionTrackingStarted()`][Listener.onSessionTrackingStarted]).
     *
     * If session with the same sessionId is already tracked, then the call does nothing.
     *
     * @param sessionId [`SessionId`][SessionId] - ID of the session to track.
     * @param state [`State`][State] - initial session tracking state.
     *
     * @throws [IllegalArgumentException] for a strict [`mode`][mode], if [`autoUntrackStates`][autoUntrackStates]
     * are defined AND sessionId is in one of such states. For a relaxed [`mode`][mode] it just logs an error message
     * and does nothing.
     * @throws [RuntimeException] for a strict [`mode`][mode], if `SessionTracker` has not been initialized.
     * For a relaxed [`mode`][mode] it just logs an error message and does nothing.
     * @throws [RuntimeException] for a strict [`mode`][mode], if
     * [`sessionStateTransitionsSupplier`][sessionStateTransitionsSupplier] returns transitions that
     * cause validation errors while creating session tracking state machine. For a relaxed [`mode`][mode] it just logs
     * an error message and does nothing.
     * @throws [RuntimeException] for a strict [`mode`][mode], if this call is initiated from the
     * [`sessionTrackerStorage`][sessionTrackerStorage]. For a relaxed [`mode`][mode] it just logs an error message
     * and does nothing.
     */
    @Synchronized
    fun trackSession(sessionId: SessionId, state: State) {
<span class="fc bfc" id="L454" title="All 2 branches covered.">        if (!ensureInitialized(&quot;trackSession&quot;)) {</span>
<span class="fc" id="L455">            return</span>
        }
<span class="fc bfc" id="L457" title="All 2 branches covered.">        if (mode.verbose) {</span>
<span class="fc" id="L458">            logger.d(logTag, &quot;trackSession: sessionId = '${sessionId}', state = $state&quot;)</span>
        }
<span class="fc bfc" id="L460" title="All 2 branches covered.">        if (!ensureNotPersisting(&quot;trackSession&quot;)) {</span>
<span class="fc" id="L461">            return</span>
        }
<span class="fc bfc" id="L463" title="All 2 branches covered.">        if (sessionsMap.contains(sessionId)) {</span>
<span class="fc" id="L464">            logger.w(logTag, &quot;trackSession: session with ID '${sessionId}' already exists&quot;)</span>
        } else {
<span class="fc bfc" id="L466" title="All 2 branches covered.">            if (state in autoUntrackStates) {</span>
<span class="fc" id="L467">                val explanation = &quot;session with ID '${sessionId}' is in auto-untrack state ($state)&quot;</span>
<span class="fc bfc" id="L468" title="All 4 branches covered.">                require(mode.strict.not()) { &quot;Unable to track session: $explanation&quot; }</span>
<span class="fc" id="L469">                logger.e(logTag, &quot;trackSession: $explanation, rejecting this session&quot;)</span>
            } else {
<span class="fc" id="L471">                val sessionRecord = SessionRecord(sessionId, state)</span>
<span class="fc" id="L472">                val stateMachine = try {</span>
<span class="fc" id="L473">                    setupSessionStateMachine(sessionRecord)</span>
<span class="fc" id="L474">                } catch (e: Exception) {</span>
<span class="fc" id="L475">                    throw RuntimeException(</span>
<span class="fc" id="L476">                        &quot;$logTag failed to track session: error creating ${StateMachine::class.java.simpleName}&quot;, e</span>
                    )
                }
<span class="fc" id="L479">                doPersistAction { sessionTrackerStorage.createSessionRecord(sessionRecord) }</span>
<span class="fc" id="L480">                sessionsMap[sessionId] = SessionInfo(stateMachine)</span>
<span class="fc" id="L481">                listener.onSessionTrackingStarted(this@SessionTracker, sessionRecord)</span>
            }
        }
<span class="fc" id="L484">    }</span>

    /**
     * Stops tracking a session with specified `sessionId`, removes corresponding session record from persistent storage
     * (via [`ISessionTrackerStorage`][ISessionTrackerStorage] implementation) and notifies session tracker listener
     * (see [`SessionTracker.Listener.onSessionTrackingStopped()`][Listener.onSessionTrackingStopped]).
     *
     * If `SessionTracker` does not track a session with specified `sessionId`, then this call does nothing.
     *
     * Note, this method does not modify session state.
     *
     * Note, it's possible to define [`autoUntrackStates`][autoUntrackStates] via `SessionTracker` constructor, so
     * sessions are untracked automatically at [`SessionTracker.consumeEvent()`][consumeEvent].
     *
     * @param sessionId [`SessionId`][SessionId].
     *
     * @throws [RuntimeException] for a strict [`mode`][mode], if `SessionTracker` has not been initialized.
     * For a relaxed [`mode`][mode] it just logs an error message and does nothing.
     * @throws [RuntimeException] for a strict [`mode`][mode], if this call is initiated from the
     * [`sessionTrackerStorage`][sessionTrackerStorage]. For a relaxed [`mode`][mode] it just logs an error message
     * and does nothing.
     */
    @Synchronized
    fun untrackSession(sessionId: SessionId) {
<span class="fc bfc" id="L508" title="All 2 branches covered.">        if (!ensureInitialized(&quot;untrackSession&quot;)) {</span>
<span class="fc" id="L509">            return</span>
        }
<span class="fc bfc" id="L511" title="All 2 branches covered.">        if (mode.verbose) {</span>
<span class="fc" id="L512">            logger.d(logTag, &quot;untrackSession: sessionId = '${sessionId}'&quot;)</span>
        }
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if (!ensureNotPersisting(&quot;untrackSession&quot;)) {</span>
<span class="fc" id="L515">            return</span>
        }
<span class="fc" id="L517">        val sessionInfo = sessionsMap[sessionId]</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">        if (sessionInfo == null) {</span>
<span class="fc" id="L519">            logger.d(logTag, &quot;untrackSession: no session with ID '$sessionId' found&quot;)</span>
        } else {
<span class="fc bfc" id="L521" title="All 2 branches covered.">            if (sessionInfo.isUntracking) {</span>
<span class="fc" id="L522">                logger.w(logTag, &quot;untrackSession: session with ID '$sessionId' is already untracking&quot;)</span>
            } else {
<span class="fc" id="L524">                sessionsMap[sessionId] = sessionInfo.copy(isUntracking = true)</span>
<span class="fc" id="L525">                doUntrackSession(sessionId, sessionInfo.stateMachine)</span>
            }
        }
<span class="fc" id="L528">    }</span>

    /**
     * Stops tracking all currently tracked sessions, removes session records from persistent storage (via
     * [`ISessionTrackerStorage`][ISessionTrackerStorage] implementation) and notifies session tracker listener
     * (see [`Listener.onAllSessionsTrackingStopped()`][Listener.onAllSessionsTrackingStopped]).
     *
     * If `SessionTracker` does not track any sessions, then this call does nothing.
     *
     * Note, this method does not modify session tracking state of the session records.
     *
     * Note, it's possible to define [`autoUntrackStates`][autoUntrackStates] via `SessionTracker` constructor, so
     * sessions are untracked automatically at [`SessionTracker.consumeEvent()`][consumeEvent].
     *
     * @throws [RuntimeException] for a strict [`mode`][mode], if `SessionTracker` has not been initialized.
     * For a relaxed [`mode`][mode] it just logs an error message and does nothing.
     * @throws [RuntimeException] for a strict [`mode`][mode], if this call is initiated from the
     * [`sessionTrackerStorage`][sessionTrackerStorage]. For a relaxed [`mode`][mode] it just logs an error message
     * and does nothing.
     */
    @Synchronized
    fun untrackAllSessions() {
<span class="fc bfc" id="L550" title="All 2 branches covered.">        if (!ensureInitialized(&quot;untrackAllSessions&quot;)) {</span>
<span class="fc" id="L551">            return</span>
        }
<span class="fc bfc" id="L553" title="All 2 branches covered.">        if (!ensureNotPersisting(&quot;untrackAllSessions&quot;)) {</span>
<span class="fc" id="L554">            return</span>
        }
<span class="fc bfc" id="L556" title="All 2 branches covered.">        if (sessionsMap.isEmpty()) {</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">            if (mode.verbose) {</span>
<span class="fc" id="L558">                logger.d(logTag, &quot;untrackAllSessions: no sessions found&quot;)</span>
            }
        } else {
<span class="fc bfc" id="L561" title="All 2 branches covered.">            if (mode.verbose) {</span>
<span class="fc" id="L562">                logger.d(logTag, &quot;untrackAllSessions&quot;)</span>
            }

<span class="fc" id="L565">            doPersistAction { sessionTrackerStorage.deleteAllSessionRecords() }</span>

<span class="fc" id="L567">            sessionsMap.values.forEach { it.stateMachine.removeAllListeners() }</span>

<span class="fc" id="L569">            val sessionRecords = sessionsMap.entries.map { (sessionId, sessionInfo) -&gt;</span>
<span class="fc" id="L570">                SessionRecord(sessionId, sessionInfo.stateMachine.getCurrentState())</span>
            }

<span class="fc" id="L573">            sessionsMap.clear()</span>

<span class="fc" id="L575">            listener.onAllSessionsTrackingStopped(this@SessionTracker, sessionRecords)</span>
        }
<span class="fc" id="L577">    }</span>

    /**
     * Attempts to apply the specified [`event`][event] to the specified session. Whether the event actually causes
     * session tracking state change depends on the session state machine configuration and current session tracking
     * state. If session tracking state change occurs, then updated session record is persisted
     * (via [`ISessionTrackerStorage`][ISessionTrackerStorage]) and session tracking listener is notified.
     *
     * If, as a result of the event consuming, the session appears in a one of the
     * [`autoUntrackStates`][autoUntrackStates] (assuming these were defined), then `SessionTracker` also stops
     * tracking the session, removes corresponding session record from the persistent storage and notifies session
     * tracking listener.
     *
     * If `SessionTracker` does not track a session with specified `sessionId`, then this call does nothing
     * and returns `false`.
     *
     * @param sessionId [`SessionId`][SessionId].
     * @param event [`Event`][Event].
     *
     * @return flag whether the event was consumed (meaning moving to a new state) or ignored.
     *
     * @throws [RuntimeException] for a strict [`mode`][mode], if `SessionTracker` has not been initialized.
     * For a relaxed [`mode`][mode] it just logs an error message and returns false.
     * @throws [RuntimeException] for a strict [`mode`][mode], if this call is initiated from the
     * [`sessionTrackerStorage`][sessionTrackerStorage]. For a relaxed [`mode`][mode] it just logs an error message
     * and returns false.
     */
    @Synchronized
    fun consumeEvent(sessionId: SessionId, event: Event): Boolean {
<span class="fc bfc" id="L606" title="All 2 branches covered.">        if (!ensureInitialized(&quot;consumeEvent&quot;)) {</span>
<span class="fc" id="L607">            return false</span>
        }
<span class="fc bfc" id="L609" title="All 2 branches covered.">        if (mode.verbose) {</span>
<span class="fc" id="L610">            logger.d(logTag, &quot;consumeEvent: sessionId = '$sessionId', event = '$event'&quot;)</span>
        }
<span class="fc bfc" id="L612" title="All 2 branches covered.">        if (!ensureNotPersisting(&quot;consumeEvent&quot;)) {</span>
<span class="fc" id="L613">            return false</span>
        }
<span class="fc" id="L615">        val sessionInfo = sessionsMap[sessionId]</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">        if (sessionInfo == null) {</span>
<span class="fc" id="L617">            logger.w(logTag, &quot;consumeEvent: no session with ID '$sessionId' found&quot;)</span>
        } else {
<span class="fc bfc" id="L619" title="All 2 branches covered.">            if (sessionInfo.isUntracking) {</span>
<span class="fc" id="L620">                logger.w(logTag, &quot;consumeEvent: event = '$event', session with ID '$sessionId' is already untracking&quot;)</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">            } else if (sessionInfo.stateMachine.consumeEvent(event)) {</span>
<span class="fc" id="L622">                return true</span>
            }
<span class="fc bfc" id="L624" title="All 2 branches covered.">            if (mode.verbose) {</span>
<span class="fc" id="L625">                logger.d(</span>
<span class="fc" id="L626">                    logTag, &quot;consumeEvent: event '$event' was ignored for session with ID '$sessionId' &quot; +</span>
<span class="fc" id="L627">                            &quot;in state ${sessionInfo.stateMachine.getCurrentState()}, &quot; +</span>
<span class="fc" id="L628">                            &quot;isUntracking = ${sessionInfo.isUntracking}&quot;</span>
                )
            }
        }
<span class="fc" id="L632">        return false</span>
    }

    private fun doUntrackSession(sessionId: SessionId, stateMachine: StateMachine&lt;Event, State&gt;) {
<span class="fc" id="L636">        stateMachine.removeAllListeners()</span>
<span class="fc" id="L637">        doPersistAction { sessionTrackerStorage.deleteSessionRecord(sessionId) }</span>
<span class="fc" id="L638">        sessionsMap.remove(sessionId)</span>
<span class="fc" id="L639">        listener.onSessionTrackingStopped(this@SessionTracker, SessionRecord(sessionId, stateMachine.getCurrentState()))</span>
<span class="fc" id="L640">    }</span>

    private fun ensureInitialized(method: String): Boolean {
<span class="fc bfc" id="L643" title="All 2 branches covered.">        if (!initialized) {</span>
<span class="fc" id="L644">            val explanation = &quot;$logTag must be initialized before calling its #$method method&quot;</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">            if (mode.strict) {</span>
<span class="fc" id="L646">                throw RuntimeException(explanation)</span>
            } else {
<span class="fc" id="L648">                logger.e(logTag, explanation)</span>
            }
        }
<span class="fc" id="L651">        return initialized</span>
    }

    private fun ensureNotPersisting(method: String): Boolean {
<span class="fc bfc" id="L655" title="All 2 branches covered.">        if (persisting) {</span>
<span class="fc" id="L656">            val explanation = &quot;$method: misuse detected, accessing &quot; +</span>
<span class="fc" id="L657">                    &quot;$logTag from ${ISessionTrackerStorage::class.java.simpleName} callbacks is not allowed&quot;</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">            if (mode.strict) {</span>
<span class="fc" id="L659">                throw RuntimeException(explanation)</span>
            } else {
<span class="fc" id="L661">                logger.e(logTag, explanation)</span>
            }
        }
<span class="fc bfc" id="L664" title="All 2 branches covered.">        return !persisting</span>
    }

    private fun setupSessionStateMachine(sessionRecord: SessionRecord&lt;State&gt;): StateMachine&lt;Event, State&gt; {
<span class="fc" id="L668">        val (sessionId, state) = sessionRecord</span>

<span class="fc" id="L670">        val builder = StateMachine.Builder&lt;Event, State&gt;().setInitialState(state)</span>

<span class="fc" id="L672">        sessionStateTransitionsSupplier.getStateTransitions(sessionId)</span>
<span class="fc" id="L673">            .forEach { transition -&gt;</span>
<span class="fc" id="L674">                builder.addTransition(</span>
<span class="fc" id="L675">                    StateMachine.Transition(transition.event, transition.statePath)</span>
                )
<span class="fc" id="L677">            }</span>

<span class="fc" id="L679">        val stateMachine = builder.build()</span>

<span class="fc" id="L681">        stateMachine.addListener(object : StateMachine.Listener&lt;State&gt; {</span>
            override fun onStateChanged(oldState: State, newState: State) {
<span class="fc" id="L683">                val baseLogMessage = &quot;onStateChanged: '$oldState' -&gt; '$newState', sessionId = '${sessionId}'&quot;</span>

<span class="fc" id="L685">                val sessionInfo = sessionsMap[sessionId]</span>

<span class="pc bpc" id="L687" title="1 of 2 branches missed.">                checkNotNull(sessionInfo) { &quot;$baseLogMessage - session not found&quot; }</span>
<span class="pc bpc" id="L688" title="2 of 4 branches missed.">                check(sessionInfo.isUntracking.not()) { &quot;$baseLogMessage - session is untracking&quot; }</span>

<span class="fc bfc" id="L690" title="All 2 branches covered.">                if (mode.verbose) {</span>
<span class="fc" id="L691">                    logger.d(logTag, baseLogMessage)</span>
                }

<span class="fc" id="L694">                val updatedSessionRecord = SessionRecord(sessionId, newState)</span>

<span class="fc bfc" id="L696" title="All 2 branches covered.">                if (newState in autoUntrackStates) {</span>
<span class="fc" id="L697">                    logger.d(logTag, &quot;$baseLogMessage, going to auto-untrack session..&quot;)</span>
<span class="fc" id="L698">                    val updatedSessionInfo = sessionInfo.copy(isUntracking = true)</span>
<span class="fc" id="L699">                    sessionsMap[sessionId] = updatedSessionInfo</span>
<span class="fc" id="L700">                    stateMachine.removeAllListeners()</span>
<span class="fc" id="L701">                    listener.onSessionStateChanged(this@SessionTracker, updatedSessionRecord, oldState)</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">                    if (sessionsMap.containsKey(sessionId)) {</span>
<span class="fc" id="L703">                        doUntrackSession(sessionId, updatedSessionInfo.stateMachine)</span>
                    }
                } else {
<span class="fc" id="L706">                    doPersistAction { sessionTrackerStorage.updateSessionRecord(updatedSessionRecord) }</span>
<span class="fc" id="L707">                    listener.onSessionStateChanged(this@SessionTracker, updatedSessionRecord, oldState)</span>
                }
<span class="fc" id="L709">            }</span>
        })

<span class="fc" id="L712">        return stateMachine</span>
    }

    private fun doPersistAction(action: () -&gt; Unit) {
<span class="fc" id="L716">        persisting = true</span>
<span class="fc" id="L717">        try {</span>
<span class="fc" id="L718">            action.invoke()</span>
        } finally {
<span class="fc" id="L720">            persisting = false</span>
        }
<span class="fc" id="L722">    }</span>

<span class="fc" id="L724">    private data class SessionInfo&lt;Event : Enum&lt;Event&gt;, State : Enum&lt;State&gt;&gt;(</span>
<span class="fc" id="L725">        val stateMachine: StateMachine&lt;Event, State&gt;,</span>
<span class="fc" id="L726">        val isUntracking: Boolean = false</span>
    )
}

typealias SessionId = String
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>