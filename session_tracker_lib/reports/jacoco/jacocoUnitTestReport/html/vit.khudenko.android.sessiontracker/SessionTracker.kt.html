<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SessionTracker.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">session_tracker_lib</a> &gt; <a href="index.source.html" class="el_package">vit.khudenko.android.sessiontracker</a> &gt; <span class="el_source">SessionTracker.kt</span></div><h1>SessionTracker.kt</h1><pre class="source lang-java linenums">package vit.khudenko.android.sessiontracker

import android.util.Log
import vit.khudenko.android.fsm.StateMachine
import java.util.*

/**
 * ## TL;DR
 *
 * SessionTracker is a general purpose framework to provide a foundation for session management in your app.
 *
 * Your app provides (a) session tracking storage implementation and (b) session tracking state machine configuration,
 * while SessionTracker provides callbacks to create/update/release session resources.
 *
 * ## Contract description
 *
 * ### What is session?
 *
 * Session is a flexible entity - it could be a user session with user signing in/out or a bluetooth device session
 * with all its possible states.
 *
 * ### Session tracking state VS. session state
 *
 * In SessionTracker framework, sessions are represented by session tracking records - instances of
 * [`SessionRecord`][SessionRecord]. It is an immutable data structure, that has just 2 fields - session ID and
 * session tracking state.
 *
 * Note, there are two (partially intersecting) types of session state:
 * 1. The session state that is tracked by SessionTracker, which is always an instance of enum by the contract.
 * 2. The session state that is specific to your app, which can be as diverse as your app's business logic requires
 * and which can not be represented by the [`SessionRecord`][SessionRecord].
 *
 * Please don't mess one with another. Actual implementation of session, including its persistence, is up to your app
 * and is out of SessionTracker framework responsibility. It is correct say that session tracking state (the one
 * tracked by SessionTracker) is a subset of a full session state in your app.
 *
 * ### Persistence
 *
 * SessionTracker framework supports session tracking auto-restoration on application process restarts. Your
 * app must provide an implementation of [`ISessionTrackerStorage`][ISessionTrackerStorage], which is used by
 * SessionTracker to make CRUD operations on session tracking records.
 *
 * ### Session tracking state machine
 *
 * SessionTracker maintains a state machine per session. Your app must define a set of possible events and
 * states per session. Using events and states, your app should provide state machine transitions, which are
 * used to configure session state machine. For example, your app may define the following session tracking events
 * and states:
 *
 * ```kotlin
 *     enum class State {
 *         INACTIVE, ACTIVE
 *     }
 *     enum class Event {
 *         LOGIN, LOGOUT
 *     }
 * ```
 *
 * then a sample transitions config (an implementation of
 * [`ISessionStateTransitionsSupplier`][ISessionStateTransitionsSupplier]) could be as following:
 *
 * ```kotlin
 *     val sessionStateTransitionsSupplier = object : ISessionStateTransitionsSupplier&lt;Event, State&gt; {
 *         override fun getStateTransitions(sessionId: SessionId) = listOf(
 *             Transition(
 *                 event = Event.LOGIN,
 *                 statePath = listOf(State.INACTIVE, State.ACTIVE)
 *             ),
 *             Transition(
 *                 event = Event.LOGOUT,
 *                 statePath = listOf(State.ACTIVE, State.INACTIVE)
 *             )
 *         )
 *     }
 * ```
 *
 * Such config would mean there are two possible session tracking states (`ACTIVE`/`INACTIVE`) and two possible session
 * tracking events: `LOGIN` (to move session from `INACTIVE` to `ACTIVE` state) and `LOGOUT` (to move session from
 * `ACTIVE` to `INACTIVE` state).
 *
 * ### Session tracking
 *
 * In order to make SessionTracker ready to function it should be initialized first. The most appropriate place for
 * [`initialize()`][initialize] call is
 * [`Application.onCreate()`][android.app.Application.onCreate].
 *
 * Suppose your user hits &quot;Login&quot; button, your app authenticates user and creates a session. In order to make
 * use of SessionTracker the session should be &quot;attached&quot; to SessionTracker:
 *
 * ```kotlin
 *     sessionTracker.trackSession(sessionId, State.ACTIVE)
 * ```
 *
 * Now SessionTracker is tracking the session until your app calls [`untrackSession(sessionId)`][untrackSession].
 * Next time your app starts (and SessionTracker is initialized), the session tracking will be automatically restored
 * by SessionTracker with the same `ACTIVE` state.
 *
 * As long as session is tracked, its session tracking state changes are propagated to your app via
 * [`SessionTracker.Listener`][SessionTracker.Listener].
 *
 * Suppose eventually your user hits &quot;Log Out&quot; button, then your app is responsible to communicate this event
 * to SessionTracker by asking to consume `LOGOUT` event for the session:
 *
 * ```kotlin
 *     sessionTracker.consumeEvent(sessionId, Event.LOGOUT)
 * ```
 *
 * Now SessionTracker updates session tracking state to `INACTIVE`, persists session record with the new state and
 * propagates this state change via [`SessionTracker.Listener`][SessionTracker.Listener]. Note, the session
 * is still tracked by SessionTracker, so next time your app starts, the session tracking will be automatically restored
 * by SessionTracker with the same `INACTIVE` state.
 *
 * ### Management of session resources
 *
 * [`SessionTracker.Listener`][SessionTracker.Listener] has useful for your app callbacks that allow to manage session
 * resources appropriately:
 *
 * - `onSessionTrackingStarted(sessionTracker: SessionTracker&lt;Event, State&gt;, sessionRecord: SessionRecord&lt;State&gt;)` -
 *     SessionTracker has added session to the list of tracked sessions.
 *     This happens as a result of calling [`SessionTracker.trackSession(sessionId, state)`][trackSession] or
 *     [`SessionTracker.initialize()`][initialize].
 *     This callback is the right place to create any resources for the session (a DB connection, a DI scope, etc.)
 *     depending on the initState.
 *
 * - `onSessionStateChanged(sessionTracker: SessionTracker&lt;Event, State&gt;, sessionRecord: SessionRecord&lt;State&gt;, oldState: State)` -
 *     session tracking state has changed.
 *     This happens as a result of calling [`SessionTracker.consumeEvent(sessionId, event)`][consumeEvent].
 *     This callback is the right place to create or release any resources for the session (a DB connection,
 *     a DI scope, etc.).
 *
 * - `onSessionTrackingStopped(sessionTracker: SessionTracker&lt;Event, State&gt;, sessionRecord: SessionRecord&lt;State&gt;)` -
 *     SessionTracker has removed session from the list of tracked sessions. This happens as a result
 *     of calling [`SessionTracker.untrackSession(sessionId)`][untrackSession].
 *     This may also happen as a result of calling [`SessionTracker.consumeEvent`][consumeEvent] if session
 *     appears in one of the [`autoUntrackStates`][autoUntrackStates].
 *     This callback is the right place to release any resources for the session (a DB connection, a DI scope, etc.).
 *
 * - `onAllSessionsTrackingStopped(sessionTracker: SessionTracker&lt;Event, State&gt;, sessionRecords: List&lt;SessionRecord&lt;State&gt;&gt;)` -
 *     SessionTracker has removed session from the list of tracked sessions. This happens as a result
 *     of calling [`SessionTracker.untrackAllSessions()`][untrackAllSessions].
 *     This callback is the right place to release any resources for the sessions (a DB connection, a DI scope, etc.).
 *
 * ## Threading
 *
 * SessionTracker is thread-safe. Public methods are declared as `synchronized`. Thread-safe compound actions are
 * possible by using synchronized statement on `SessionTracker` instance:
 *
 * ```kotlin
 *     synchronized(sessionTracker) {
 *         sessionTracker.consumeEvent(..) // step 1 of the compound action
 *         sessionTracker.consumeEvent(..) // step 2 of the compound action
 *     }
 * ```
 *
 * SessionTracker is a synchronous tool, meaning it neither creates threads nor uses thread-pools.
 *
 * ## Miscellaneous
 *
 * Typical SessionTracker usage implies being a singleton in your app.
 */
<span class="fc" id="L161">class SessionTracker&lt;Event : Enum&lt;Event&gt;, State : Enum&lt;State&gt;&gt;(</span>
    private val sessionTrackerStorage: ISessionTrackerStorage&lt;State&gt;,
    private val sessionStateTransitionsSupplier: ISessionStateTransitionsSupplier&lt;Event, State&gt;,
    private val listener: Listener&lt;Event, State&gt;,
    /**
     * If a session appears in one of these states, then `SessionTracker` automatically untracks such session.
     * The effect of automatic untracking is similar to making an explicit [`untrackSession()`][untrackSession] call.
     *
     * @see [consumeEvent]
     * @see [untrackSession]
     * @see [untrackAllSessions]
     */
    private val autoUntrackStates: Set&lt;State&gt;,
    private val mode: Mode,
    private val logger: Logger = Logger.DefaultImpl()
) {

    companion object {
<span class="fc" id="L179">        internal val TAG = SessionTracker::class.java.simpleName</span>
    }

    /**
     * Defines misuse/misconfiguration tolerance and amount of logging.
     *
     * @see [Mode.STRICT]
     * @see [Mode.STRICT_VERBOSE]
     * @see [Mode.RELAXED]
     * @see [Mode.RELAXED_VERBOSE]
     */
<span class="fc" id="L190">    enum class Mode(val strict: Boolean, val verbose: Boolean) {</span>

        /**
         * In this mode SessionTracker does not tolerate most of the misuse/misconfiguration issues by crashing the app.
         *
         * @see [initialize]
         * @see [trackSession]
         * @see [untrackSession]
         * @see [consumeEvent]
         */
<span class="fc" id="L200">        STRICT(strict = true, verbose = false),</span>

        /**
         * Same as [`STRICT`][STRICT], but with more logging.
         */
<span class="fc" id="L205">        STRICT_VERBOSE(strict = true, verbose = true),</span>

        /**
         * In this mode SessionTracker tries to overstep misuse/misconfiguration issues (if possible) by just logging
         * the issue and turning an operation to 'no op'.
         *
         * @see [initialize]
         * @see [trackSession]
         * @see [untrackSession]
         * @see [consumeEvent]
         */
<span class="fc" id="L216">        RELAXED(strict = false, verbose = false),</span>

        /**
         * Same as [`RELAXED`][RELAXED], but with more logging.
         */
<span class="fc" id="L221">        RELAXED_VERBOSE(strict = false, verbose = true)</span>
    }

    /**
     * A listener, through which the session tracking lifecycle and state changes are communicated.
     *
     * @see [onSessionTrackingStarted]
     * @see [onSessionTrackingStopped]
     * @see [onSessionStateChanged]
     * @see [onAllSessionsTrackingStopped]
     */
    interface Listener&lt;Event : Enum&lt;Event&gt;, State : Enum&lt;State&gt;&gt; {

        /**
         * The `SessionTracker` has added session to the list of tracked sessions. This happens as a result
         * of calling [`SessionTracker.trackSession()`][trackSession] or [`SessionTracker.initialize()`][initialize].
         *
         * This callback is the right place to create any resources for the session
         * (a DB connection, a DI scope, etc.).
         */
        fun onSessionTrackingStarted(
            sessionTracker: SessionTracker&lt;Event, State&gt;,
            sessionRecord: SessionRecord&lt;State&gt;
        )

        /**
         * The session tracking state has changed from `oldState` to `newState`.
         * This happens as a result of calling [`SessionTracker.consumeEvent()`][consumeEvent].
         *
         * This callback is the right place to create or release any resources
         * for the session (a DB connection, a DI scope, etc.).
         */
        fun onSessionStateChanged(
            sessionTracker: SessionTracker&lt;Event, State&gt;,
            sessionRecord: SessionRecord&lt;State&gt;,
            oldState: State
        )

        /**
         * The `SessionTracker` has removed session from the list of tracked sessions. This happens as a result
         * of calling [`SessionTracker.untrackSession()`][untrackSession].
         *
         * This may also happen as a result of calling [`SessionTracker.consumeEvent()`][SessionTracker.consumeEvent]
         * if session appears in one of the [`autoUntrackStates`][autoUntrackStates].
         *
         * This callback is the right place to release any resources for
         * the session (a DB connection, a DI scope, etc.).
         */
        fun onSessionTrackingStopped(
            sessionTracker: SessionTracker&lt;Event, State&gt;,
            sessionRecord: SessionRecord&lt;State&gt;
        )

        /**
         * The `SessionTracker` has removed all sessions from the list of tracked sessions. This happens as a result
         * of calling [`SessionTracker.untrackAllSessions()`][untrackAllSessions].
         *
         * This callback is the right place to release any resources for
         * the sessions (a DB connection, a DI scope, etc.).
         */
        fun onAllSessionsTrackingStopped(
            sessionTracker: SessionTracker&lt;Event, State&gt;,
            sessionRecords: List&lt;SessionRecord&lt;State&gt;&gt;
        )
    }

    interface Logger {
        fun d(tag: String, message: String)
        fun w(tag: String, message: String)
        fun e(tag: String, message: String)

        /**
         * Default implementation of [`Logger`][Logger] that uses [`android.util.Log`][android.util.Log].
         */
<span class="fc" id="L295">        class DefaultImpl : Logger {</span>
            override fun d(tag: String, message: String) {
<span class="fc" id="L297">                Log.d(tag, message)</span>
<span class="fc" id="L298">            }</span>

            override fun w(tag: String, message: String) {
<span class="fc" id="L301">                Log.w(tag, message)</span>
<span class="fc" id="L302">            }</span>

            override fun e(tag: String, message: String) {
<span class="fc" id="L305">                Log.e(tag, message)</span>
<span class="fc" id="L306">            }</span>
        }
    }

    private var initialized: Boolean = false
<span class="fc" id="L311">    private val sessionsMap = LinkedHashMap&lt;SessionId, SessionInfo&lt;Event, State&gt;&gt;()</span>
    private var persisting = false

    /**
     * Must be called before calling any other methods.
     *
     * Subsequent calls are ignored.
     *
     * This method calls [`ISessionTrackerStorage.readAllSessionRecords()`][ISessionTrackerStorage.readAllSessionRecords],
     * starts tracking the obtained session records and notifies session tracker listener (see
     * [`Listener.onSessionTrackingStarted()`][Listener.onSessionTrackingStarted]).
     *
     * @throws [RuntimeException] for a strict [`mode`][mode], if [`autoUntrackStates`][autoUntrackStates] are defined
     * AND session is in one of such states. For a relaxed [`mode`][mode] it just logs an error message and skips such
     * session from tracking.
     * @throws [RuntimeException] for a strict [`mode`][mode], if
     * [`sessionStateTransitionsSupplier`][sessionStateTransitionsSupplier] returns transitions that cause validation
     * errors while creating session tracking state machine. For a relaxed [`mode`][mode] it just logs an error
     * message and skips such session from tracking.
     */
    @Synchronized
    fun initialize() {
<span class="fc" id="L333">        val startedAt = System.currentTimeMillis()</span>

<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (initialized) {</span>
<span class="fc" id="L336">            logger.w(TAG, &quot;initialize: already initialized, skipping..&quot;)</span>
<span class="fc" id="L337">            return</span>
        }

<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (mode.verbose) {</span>
<span class="fc" id="L341">            logger.d(TAG, &quot;initialize: starting..&quot;)</span>
        }

<span class="fc" id="L344">        val loadedSessionRecords = sessionTrackerStorage.readAllSessionRecords()</span>

<span class="fc" id="L346">        loadedSessionRecords</span>
<span class="fc" id="L347">            .filter { sessionRecord -&gt;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">                sessionRecord.state in autoUntrackStates</span>
<span class="fc" id="L349">            }.forEach { (sessionId, state) -&gt;</span>
<span class="fc" id="L350">                val explanation = &quot;session with ID '${sessionId}' is in auto-untrack state (${state})&quot;</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">                if (mode.strict) {</span>
<span class="fc" id="L352">                    throw RuntimeException(&quot;Unable to initialize $TAG: $explanation&quot;)</span>
                } else {
<span class="fc" id="L354">                    logger.e(TAG, &quot;initialize: $explanation, rejecting this session&quot;)</span>
                }
<span class="fc" id="L356">            }</span>

<span class="fc" id="L358">        loadedSessionRecords</span>
<span class="fc" id="L359">            .filterNot { sessionRecord -&gt;</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">                sessionRecord.state in autoUntrackStates</span>
            }
<span class="fc" id="L362">            .map { sessionRecord -&gt;</span>
<span class="fc" id="L363">                val stateMachine = try {</span>
<span class="fc" id="L364">                    setupSessionStateMachine(sessionRecord)</span>
<span class="fc" id="L365">                } catch (e: Exception) {</span>
<span class="fc" id="L366">                    throw RuntimeException(</span>
<span class="fc" id="L367">                        &quot;Unable to initialize $TAG: error creating ${StateMachine::class.java.simpleName}&quot;, e</span>
                    )
                }
<span class="fc" id="L370">                sessionRecord to stateMachine</span>
            }
<span class="fc" id="L372">            .forEach { (sessionRecord, stateMachine) -&gt;</span>
<span class="fc" id="L373">                sessionsMap[sessionRecord.sessionId] = SessionInfo(stateMachine)</span>
<span class="fc" id="L374">                listener.onSessionTrackingStarted(this@SessionTracker, sessionRecord)</span>
<span class="fc" id="L375">            }</span>

<span class="fc" id="L377">        initialized = true</span>

<span class="fc bfc" id="L379" title="All 2 branches covered.">        if (mode.verbose) {</span>
<span class="fc" id="L380">            logger.d(TAG, &quot;initialize: done, took ${System.currentTimeMillis() - startedAt} ms&quot;)</span>
        }
<span class="fc" id="L382">    }</span>

    /**
     * @return a list of the currently tracked session records.
     *
     * @throws [RuntimeException] for a strict [`mode`][mode], if `SessionTracker` has not been initialized.
     * For a relaxed [`mode`][mode] it just logs an error message and returns an empty list.
     */
    @Synchronized
    fun getSessionRecords(): List&lt;SessionRecord&lt;State&gt;&gt; {
<span class="fc bfc" id="L392" title="All 2 branches covered.">        return if (ensureInitialized(&quot;getSessionRecords&quot;)) {</span>
<span class="fc" id="L393">            val sessionRecords = sessionsMap.entries.map {</span>
<span class="fc" id="L394">                SessionRecord(sessionId = it.key, state = it.value.stateMachine.getCurrentState())</span>
<span class="fc" id="L395">            }.toMutableList()</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">            if (mode.verbose) {</span>
<span class="fc" id="L397">                val dump = sessionRecords.joinToString(</span>
<span class="fc" id="L398">                    prefix = &quot;[&quot;, postfix = &quot;]&quot;</span>
<span class="fc" id="L399">                ) { (sessionId, state) -&gt; &quot;{ '${sessionId}': $state }&quot; }</span>
<span class="fc" id="L400">                logger.d(TAG, &quot;getSessionRecords: $dump&quot;)</span>
            }
<span class="fc" id="L402">            sessionRecords</span>
        } else {
<span class="fc" id="L404">            emptyList()</span>
        }
    }

    /**
     * Starts tracking a session for the sessionId, persists a new session record via
     * [`ISessionTrackerStorage`][ISessionTrackerStorage] and notifies session tracker listener
     * (see [`SessionTracker.Listener.onSessionTrackingStarted()`][Listener.onSessionTrackingStarted]).
     *
     * If session with the same sessionId is already tracked, then the call does nothing.
     *
     * @param sessionId [`SessionId`][SessionId] - ID of the session to track.
     * @param state [`State`][State] - initial session tracking state.
     *
     * @throws [IllegalArgumentException] for a strict [`mode`][mode], if [`autoUntrackStates`][autoUntrackStates]
     * are defined AND sessionId is in one of such states. For a relaxed [`mode`][mode] it just logs an error message
     * and does nothing.
     * @throws [RuntimeException] for a strict [`mode`][mode], if `SessionTracker` has not been initialized.
     * For a relaxed [`mode`][mode] it just logs an error message and does nothing.
     * @throws [RuntimeException] for a strict [`mode`][mode], if
     * [`sessionStateTransitionsSupplier`][sessionStateTransitionsSupplier] returns transitions that
     * cause validation errors while creating session tracking state machine. For a relaxed [`mode`][mode] it just logs
     * an error message and does nothing.
     * @throws [RuntimeException] for a strict [`mode`][mode], if this call is initiated from the
     * [`sessionTrackerStorage`][sessionTrackerStorage]. For a relaxed [`mode`][mode] it just logs an error message
     * and does nothing.
     */
    @Synchronized
    fun trackSession(sessionId: SessionId, state: State) {
<span class="fc bfc" id="L433" title="All 2 branches covered.">        if (!ensureInitialized(&quot;trackSession&quot;)) {</span>
<span class="fc" id="L434">            return</span>
        }
<span class="fc bfc" id="L436" title="All 2 branches covered.">        if (mode.verbose) {</span>
<span class="fc" id="L437">            logger.d(TAG, &quot;trackSession: sessionId = '${sessionId}', state = $state&quot;)</span>
        }
<span class="fc bfc" id="L439" title="All 2 branches covered.">        if (!ensureNotPersisting(&quot;trackSession&quot;)) {</span>
<span class="fc" id="L440">            return</span>
        }
<span class="fc bfc" id="L442" title="All 2 branches covered.">        if (sessionsMap.contains(sessionId)) {</span>
<span class="fc" id="L443">            logger.w(TAG, &quot;trackSession: session with ID '${sessionId}' already exists&quot;)</span>
        } else {
<span class="fc bfc" id="L445" title="All 2 branches covered.">            if (state in autoUntrackStates) {</span>
<span class="fc" id="L446">                val explanation = &quot;session with ID '${sessionId}' is in auto-untrack state ($state)&quot;</span>
<span class="fc bfc" id="L447" title="All 4 branches covered.">                require(mode.strict.not()) { &quot;Unable to track session: $explanation&quot; }</span>
<span class="fc" id="L448">                logger.e(TAG, &quot;trackSession: $explanation, rejecting this session&quot;)</span>
            } else {
<span class="fc" id="L450">                val sessionRecord = SessionRecord(sessionId, state)</span>
<span class="fc" id="L451">                val stateMachine = try {</span>
<span class="fc" id="L452">                    setupSessionStateMachine(sessionRecord)</span>
<span class="fc" id="L453">                } catch (e: Exception) {</span>
<span class="fc" id="L454">                    throw RuntimeException(</span>
<span class="fc" id="L455">                        &quot;$TAG failed to track session: error creating ${StateMachine::class.java.simpleName}&quot;, e</span>
                    )
                }
<span class="fc" id="L458">                doPersistAction { sessionTrackerStorage.createSessionRecord(sessionRecord) }</span>
<span class="fc" id="L459">                sessionsMap[sessionId] = SessionInfo(stateMachine)</span>
<span class="fc" id="L460">                listener.onSessionTrackingStarted(this@SessionTracker, sessionRecord)</span>
            }
        }
<span class="fc" id="L463">    }</span>

    /**
     * Stops tracking a session with specified `sessionId`, removes corresponding session record from persistent storage
     * (via [`ISessionTrackerStorage`][ISessionTrackerStorage] implementation) and notifies session tracker listener
     * (see [`SessionTracker.Listener.onSessionTrackingStopped()`][Listener.onSessionTrackingStopped]).
     *
     * If `SessionTracker` does not track a session with specified `sessionId`, then this call does nothing.
     *
     * Note, this method does not modify session state.
     *
     * Note, it's possible to define [`autoUntrackStates`][autoUntrackStates] via `SessionTracker` constructor, so
     * sessions are untracked automatically at [`SessionTracker.consumeEvent()`][consumeEvent].
     *
     * @param sessionId [`SessionId`][SessionId].
     *
     * @throws [RuntimeException] for a strict [`mode`][mode], if `SessionTracker` has not been initialized.
     * For a relaxed [`mode`][mode] it just logs an error message and does nothing.
     * @throws [RuntimeException] for a strict [`mode`][mode], if this call is initiated from the
     * [`sessionTrackerStorage`][sessionTrackerStorage]. For a relaxed [`mode`][mode] it just logs an error message
     * and does nothing.
     */
    @Synchronized
    fun untrackSession(sessionId: SessionId) {
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if (!ensureInitialized(&quot;untrackSession&quot;)) {</span>
<span class="fc" id="L488">            return</span>
        }
<span class="fc bfc" id="L490" title="All 2 branches covered.">        if (mode.verbose) {</span>
<span class="fc" id="L491">            logger.d(TAG, &quot;untrackSession: sessionId = '${sessionId}'&quot;)</span>
        }
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (!ensureNotPersisting(&quot;untrackSession&quot;)) {</span>
<span class="fc" id="L494">            return</span>
        }
<span class="fc" id="L496">        val sessionInfo = sessionsMap[sessionId]</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">        if (sessionInfo == null) {</span>
<span class="fc" id="L498">            logger.d(TAG, &quot;untrackSession: no session with ID '$sessionId' found&quot;)</span>
        } else {
<span class="fc bfc" id="L500" title="All 2 branches covered.">            if (sessionInfo.isUntracking) {</span>
<span class="fc" id="L501">                logger.w(TAG, &quot;untrackSession: session with ID '$sessionId' is already untracking&quot;)</span>
            } else {
<span class="fc" id="L503">                sessionsMap[sessionId] = sessionInfo.copy(isUntracking = true)</span>
<span class="fc" id="L504">                doUntrackSession(sessionId, sessionInfo.stateMachine)</span>
            }
        }
<span class="fc" id="L507">    }</span>

    /**
     * Stops tracking all currently tracked sessions, removes session records from persistent storage (via
     * [`ISessionTrackerStorage`][ISessionTrackerStorage] implementation) and notifies session tracker listener
     * (see [`Listener.onAllSessionsTrackingStopped()`][Listener.onAllSessionsTrackingStopped]).
     *
     * If `SessionTracker` does not track any sessions, then this call does nothing.
     *
     * Note, this method does not modify session tracking state of the session records.
     *
     * Note, it's possible to define [`autoUntrackStates`][autoUntrackStates] via `SessionTracker` constructor, so
     * sessions are untracked automatically at [`SessionTracker.consumeEvent()`][consumeEvent].
     *
     * @throws [RuntimeException] for a strict [`mode`][mode], if `SessionTracker` has not been initialized.
     * For a relaxed [`mode`][mode] it just logs an error message and does nothing.
     * @throws [RuntimeException] for a strict [`mode`][mode], if this call is initiated from the
     * [`sessionTrackerStorage`][sessionTrackerStorage]. For a relaxed [`mode`][mode] it just logs an error message
     * and does nothing.
     */
    @Synchronized
    fun untrackAllSessions() {
<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (!ensureInitialized(&quot;untrackAllSessions&quot;)) {</span>
<span class="fc" id="L530">            return</span>
        }
<span class="fc bfc" id="L532" title="All 2 branches covered.">        if (!ensureNotPersisting(&quot;untrackAllSessions&quot;)) {</span>
<span class="fc" id="L533">            return</span>
        }
<span class="fc bfc" id="L535" title="All 2 branches covered.">        if (sessionsMap.isEmpty()) {</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">            if (mode.verbose) {</span>
<span class="fc" id="L537">                logger.d(TAG, &quot;untrackAllSessions: no sessions found&quot;)</span>
            }
        } else {
<span class="fc bfc" id="L540" title="All 2 branches covered.">            if (mode.verbose) {</span>
<span class="fc" id="L541">                logger.d(TAG, &quot;untrackAllSessions&quot;)</span>
            }

<span class="fc" id="L544">            doPersistAction { sessionTrackerStorage.deleteAllSessionRecords() }</span>

<span class="fc" id="L546">            sessionsMap.values.forEach { it.stateMachine.removeAllListeners() }</span>

<span class="fc" id="L548">            val sessionRecords = sessionsMap.entries.map { (sessionId, sessionInfo) -&gt;</span>
<span class="fc" id="L549">                SessionRecord(sessionId, sessionInfo.stateMachine.getCurrentState())</span>
            }

<span class="fc" id="L552">            sessionsMap.clear()</span>

<span class="fc" id="L554">            listener.onAllSessionsTrackingStopped(this@SessionTracker, sessionRecords)</span>
        }
<span class="fc" id="L556">    }</span>

    /**
     * Attempts to apply the specified [`event`][event] to the specified session. Whether the event actually causes
     * session tracking state change depends on the session state machine configuration and current session tracking
     * state. If session tracking state change occurs, then updated session record is persisted
     * (via [`ISessionTrackerStorage`][ISessionTrackerStorage]) and session tracking listener is notified.
     *
     * If, as a result of the event consuming, the session appears in a one of the
     * [`autoUntrackStates`][autoUntrackStates] (assuming these were defined), then `SessionTracker` also stops
     * tracking the session, removes corresponding session record from the persistent storage and notifies session
     * tracking listener.
     *
     * If `SessionTracker` does not track a session with specified `sessionId`, then this call does nothing
     * and returns `false`.
     *
     * @param sessionId [`SessionId`][SessionId].
     * @param event [`Event`][Event].
     *
     * @return flag whether the event was consumed (meaning moving to a new state) or ignored.
     *
     * @throws [RuntimeException] for a strict [`mode`][mode], if `SessionTracker` has not been initialized.
     * For a relaxed [`mode`][mode] it just logs an error message and returns false.
     * @throws [RuntimeException] for a strict [`mode`][mode], if this call is initiated from the
     * [`sessionTrackerStorage`][sessionTrackerStorage]. For a relaxed [`mode`][mode] it just logs an error message
     * and returns false.
     */
    @Synchronized
    fun consumeEvent(sessionId: SessionId, event: Event): Boolean {
<span class="fc bfc" id="L585" title="All 2 branches covered.">        if (!ensureInitialized(&quot;consumeEvent&quot;)) {</span>
<span class="fc" id="L586">            return false</span>
        }
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (mode.verbose) {</span>
<span class="fc" id="L589">            logger.d(TAG, &quot;consumeEvent: sessionId = '$sessionId', event = '$event'&quot;)</span>
        }
<span class="fc bfc" id="L591" title="All 2 branches covered.">        if (!ensureNotPersisting(&quot;consumeEvent&quot;)) {</span>
<span class="fc" id="L592">            return false</span>
        }
<span class="fc" id="L594">        val sessionInfo = sessionsMap[sessionId]</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">        if (sessionInfo == null) {</span>
<span class="fc" id="L596">            logger.w(TAG, &quot;consumeEvent: no session with ID '$sessionId' found&quot;)</span>
        } else {
<span class="fc bfc" id="L598" title="All 2 branches covered.">            if (sessionInfo.isUntracking) {</span>
<span class="fc" id="L599">                logger.w(TAG, &quot;consumeEvent: event = '$event', session with ID '$sessionId' is already untracking&quot;)</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">            } else if (sessionInfo.stateMachine.consumeEvent(event)) {</span>
<span class="fc" id="L601">                return true</span>
            }
<span class="fc bfc" id="L603" title="All 2 branches covered.">            if (mode.verbose) {</span>
<span class="fc" id="L604">                logger.d(</span>
<span class="fc" id="L605">                    TAG, &quot;consumeEvent: event '$event' was ignored for session with ID '$sessionId' &quot; +</span>
<span class="fc" id="L606">                            &quot;in state ${sessionInfo.stateMachine.getCurrentState()}, &quot; +</span>
<span class="fc" id="L607">                            &quot;isUntracking = ${sessionInfo.isUntracking}&quot;</span>
                )
            }
        }
<span class="fc" id="L611">        return false</span>
    }

    private fun doUntrackSession(sessionId: SessionId, stateMachine: StateMachine&lt;Event, State&gt;) {
<span class="fc" id="L615">        stateMachine.removeAllListeners()</span>
<span class="fc" id="L616">        doPersistAction { sessionTrackerStorage.deleteSessionRecord(sessionId) }</span>
<span class="fc" id="L617">        sessionsMap.remove(sessionId)</span>
<span class="fc" id="L618">        listener.onSessionTrackingStopped(this@SessionTracker, SessionRecord(sessionId, stateMachine.getCurrentState()))</span>
<span class="fc" id="L619">    }</span>

    private fun ensureInitialized(method: String): Boolean {
<span class="fc bfc" id="L622" title="All 2 branches covered.">        if (!initialized) {</span>
<span class="fc" id="L623">            val explanation = &quot;$TAG must be initialized before calling its #$method method&quot;</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">            if (mode.strict) {</span>
<span class="fc" id="L625">                throw RuntimeException(explanation)</span>
            } else {
<span class="fc" id="L627">                logger.e(TAG, explanation)</span>
            }
        }
<span class="fc" id="L630">        return initialized</span>
    }

    private fun ensureNotPersisting(method: String): Boolean {
<span class="fc bfc" id="L634" title="All 2 branches covered.">        if (persisting) {</span>
<span class="fc" id="L635">            val explanation = &quot;$method: misuse detected, accessing &quot; +</span>
<span class="fc" id="L636">                    &quot;$TAG from ${ISessionTrackerStorage::class.java.simpleName} callbacks is not allowed&quot;</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">            if (mode.strict) {</span>
<span class="fc" id="L638">                throw RuntimeException(explanation)</span>
            } else {
<span class="fc" id="L640">                logger.e(TAG, explanation)</span>
            }
        }
<span class="fc bfc" id="L643" title="All 2 branches covered.">        return !persisting</span>
    }

    private fun setupSessionStateMachine(sessionRecord: SessionRecord&lt;State&gt;): StateMachine&lt;Event, State&gt; {
<span class="fc" id="L647">        val (sessionId, state) = sessionRecord</span>

<span class="fc" id="L649">        val builder = StateMachine.Builder&lt;Event, State&gt;().setInitialState(state)</span>

<span class="fc" id="L651">        sessionStateTransitionsSupplier.getStateTransitions(sessionId)</span>
<span class="fc" id="L652">            .forEach { transition -&gt;</span>
<span class="fc" id="L653">                builder.addTransition(</span>
<span class="fc" id="L654">                    StateMachine.Transition(transition.event, transition.statePath)</span>
                )
<span class="fc" id="L656">            }</span>

<span class="fc" id="L658">        val stateMachine = builder.build()</span>

<span class="fc" id="L660">        stateMachine.addListener(object : StateMachine.Listener&lt;State&gt; {</span>
            override fun onStateChanged(oldState: State, newState: State) {
<span class="fc" id="L662">                val baseLogMessage = &quot;onStateChanged: '$oldState' -&gt; '$newState', sessionId = '${sessionId}'&quot;</span>

<span class="fc" id="L664">                val sessionInfo = sessionsMap[sessionId]</span>

<span class="pc bpc" id="L666" title="1 of 2 branches missed.">                checkNotNull(sessionInfo) { &quot;$baseLogMessage - session not found&quot; }</span>
<span class="pc bpc" id="L667" title="2 of 4 branches missed.">                check(sessionInfo.isUntracking.not()) { &quot;$baseLogMessage - session is untracking&quot; }</span>

<span class="fc bfc" id="L669" title="All 2 branches covered.">                if (mode.verbose) {</span>
<span class="fc" id="L670">                    logger.d(TAG, baseLogMessage)</span>
                }

<span class="fc" id="L673">                val updatedSessionRecord = SessionRecord(sessionId, newState)</span>

<span class="fc bfc" id="L675" title="All 2 branches covered.">                if (newState in autoUntrackStates) {</span>
<span class="fc" id="L676">                    logger.d(TAG, &quot;$baseLogMessage, going to auto-untrack session..&quot;)</span>
<span class="fc" id="L677">                    val updatedSessionInfo = sessionInfo.copy(isUntracking = true)</span>
<span class="fc" id="L678">                    sessionsMap[sessionId] = updatedSessionInfo</span>
<span class="fc" id="L679">                    stateMachine.removeAllListeners()</span>
<span class="fc" id="L680">                    listener.onSessionStateChanged(this@SessionTracker, updatedSessionRecord, oldState)</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">                    if (sessionsMap.containsKey(sessionId)) {</span>
<span class="fc" id="L682">                        doUntrackSession(sessionId, updatedSessionInfo.stateMachine)</span>
                    }
                } else {
<span class="fc" id="L685">                    doPersistAction { sessionTrackerStorage.updateSessionRecord(updatedSessionRecord) }</span>
<span class="fc" id="L686">                    listener.onSessionStateChanged(this@SessionTracker, updatedSessionRecord, oldState)</span>
                }
<span class="fc" id="L688">            }</span>
        })

<span class="fc" id="L691">        return stateMachine</span>
    }

    private fun doPersistAction(action: () -&gt; Unit) {
<span class="fc" id="L695">        persisting = true</span>
<span class="fc" id="L696">        try {</span>
<span class="fc" id="L697">            action.invoke()</span>
        } finally {
<span class="fc" id="L699">            persisting = false</span>
        }
<span class="fc" id="L701">    }</span>

<span class="fc" id="L703">    private data class SessionInfo&lt;Event : Enum&lt;Event&gt;, State : Enum&lt;State&gt;&gt;(</span>
<span class="fc" id="L704">        val stateMachine: StateMachine&lt;Event, State&gt;,</span>
<span class="fc" id="L705">        val isUntracking: Boolean = false</span>
    )
}

typealias SessionId = String
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>